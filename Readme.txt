1조 조원 구성 및 역할

20203043 권수현 - 

20203058 남태인 - 

20203072 안민호 – 



1. 프로그램 구성요소 : data.py, cache.py, client.py

◆ data.py 구성요소

- 


◆ cache.py 구성요소

-

◆ client.py 구성요소

-


2. 소스코드 컴파일 방법 (GCP 사용)

① 구글 클라우드에 접속하여 VM instance를 생성한다.
	지역 : us-central1로 설정
	머신 유형 : e2-micro
	부팅 디스크 : Debian

② 방화벽 규칙을 추가한다
	대상 : 모든 인스턴스 선택
	소스 IP 범위 : 0.0.0.0/0  (모든 IP 주소 허용)
	프로토콜 및 포트 : TCP와 해당 포트를 지정 (port : 9999)

③ 생성된 인스턴스의 SSH를 실행한다.

④ Python과 개발 도구의 패키지들을 설치한다 (Debian 기준)
	sudo apt update
	sudo apt install python3
	sudo apt install python3-pip
	pip install numpy
	pip install numpy scipy
	pip install loguru //Python에서 로그(logging)기능을 제공하는 라이브러리

⑤ 가상환경을 생성하고 활성화한다.
	python3 -m venv myenv(가상환경 이름)
	source myenv/bin/activate //가상환경 활성화

⑥ UPLOAD FILE을 클릭하여 server.py를 업로드한다.
	server.py가 업로드된 디렉터리에서 python3 server.py로 Data server를 실행한다.

⑦ 로컬에서 powershell 터미널 6개를 열어 터미널 2개는 python3 cache.py로 캐시 서버를 실행시키고, 나머지 터미널 4개는 python3 client.py로 client를 실행한다.
	
⑧ 2개의 Cache server와 4개의 client가 모두 연결되면 프로그램이 실행된다.

3. 규칙 및 알고리즘 설명

⦁ 알고리즘 시나리오

### 클라이언트 초기 설정

각각의 클라이언트가 요청할 랜덤 파일 리스트를 생성 후, 정렬

정렬된 리스트를 데이터 서버에 전송,

### 데이터 서버 초기 설정

데이터 서버는 [np.zero](http://np.zero) 1x10000 행렬을 만든다

데이터 서버 행렬

- 데이터 서버의 파일 요청 개수(=파일 다운 횟수) 행렬에 업데이트 (3개면 0 → 3)
- 데이터 서버→ 캐시로 파일 보낸 경우, 해당 파일의 파일 요청 개수는 0으로 업데이트
- 데이터 서버→클라이언트로 파일 보낸 경우, 해당 파일의 요청 개수는 -1

데이터 서버 파일 생성

### 데이터 서버 →캐시에 파일 전송

데이터 서버가 캐시에 파일과 파일별 다운 횟수 전송(크기가 작은 파일부터 우선적으로 보냄)

- 캐시는 홀수 파일 캐시와 짝수 파일 캐시로 이루어져있음
- 데이터 서버의 행렬은 파일이 캐시로 보내진 경우, 해당 파일 요청 개수를 0으로 업데이트 한다.
- 캐시에 보낸 파일 번호 중 가장 큰 (max) 파일 번호를 저장

### 캐시 파일 요청 받은 경우

캐시에 클라이언트가 요청한 파일이 존재하는 경우, 클라이언트에게 파일을 전송하고 파일 요청 횟수를 1 줄인다.

- 파일 요청 횟수가 0이되면 캐시에서 제거 우선 순위가 높아진다.
- 파일 요청 횟수가 0인 파일들의 파일 크기 합(=캐시의 빈공간)이 데이터 서버로 부터 받는 새 파일의 크기보다 큰경우 새 파일을 받는다.**(캐시-데이터 서버에 파일 요청(캐시 업데이트))**

캐시에 클라이언트가 요청한 파일이 존재하지 않는 경우, 클라이언트에 “캐시에 요청한 n번 파일 없음” 메시지를 보낸다

### 캐시—>데이터 서버에 파일 요청(캐시 업데이트)

1. 데이터 서버는 cache가 다음 요청 해야할 파일 번호를 스레드를 통해 계속 보낸다
2. 캐시는 [빈 공간 > max_file_num] 일 때 데이터 서버에게 request:max_file_num 메시지를 보낸다
3. 데이터 서버는 캐시가 요청한 파일을 보내준다.
4. 데이터 서버가 가진 파일을 모두 보냈을 때 (data_array의 모든 값이 0이 되었을 때) FLAG:0 메시지를 보낸다.

### 클라이언트→캐시 파일 요청

클라이언트는 캐시에게 파일을 요청함(작은 파일을 우선적으로 요청)

캐시에 요청 파일이 존재하지 않는 경우 클라이언트는 데이터 서버에게 파일을 요청

- 데이터 서버는 클라이언트가 직접 파일을 요청한 경우, 해당 파일 요청 개수를 1 줄인다

### 클라이언트 → 데이터 서버 파일 요청(큰 파일)

클라이언트는 캐시에 파일을 요청할 때 크기가 작은 파일 여러개와 큰 파일 하나를 요청한다.

초기 캐시 서버에는 큰 파일이 없을 가능성이 높으므로 캐시 서버는 큰 파일을 높은 확률로 거절한다.

그러면 클라이언트는 큰 파일을 데이터 서버에게 직접 요청한다

### 프로그램 종료 과정

데이터 서버 행렬의 모든 값이 0이 되고 모든 클라이언트가 다운 완료가 파일의 개수가 각각 1000개인 경우 그레이스풀리 터미널 절차에 들어감

### 메시지 형식

- FLAG:1 (설명: 데이터 서버의 파일 준비가 끝나면 다른 cache와 client에게 시작하라고 보내는 신호)
- FILE:file_num:file_data:max_file_num:request_cnt    (설명 파일 데이터 전송 시 , FILE: 파일 번호 : 파일 데이터:캐시에 보내지는 파일 중 가장 크기가 큰 파일 번호:파일 요청 횟수)
- REQUEST:file_num (설명: 파일 요청 메시지 , REQUEST: 파일 번호)
- RANDOM:client에서 data server에 요청할 random 1000개 파일 목록
    
    ㄴRANDOM:random_list
    
- NEXT:file_num(설명: 캐시가 다음에 받을 파일을 알려주기위한 메시지)

구현 순서
ⓐ 클라이언트가 캐시 서버에 파일 요청

캐시 서버는 파일을 있는지 확인(전체 스캔)
있으면 파일을 주고 if 파일이 없을 때 client에게 없다라는
메시지 + 해당 파일 번호 전송

ⓑ client가 캐시 서버가 없다라는 메시지를 받았을 때
data server에 해당 파일을 요청하고
data server에게 받음
ⓒ 캐시 서버가 데이터 서버에 25MB파일을 요청 (캐시 서버 초기 세팅)
ⓓ 가상 파일로 테스트 하던거 실제 메모리 파일로 수정
ⓔ 캐시 서버 업데이트
ⓕ 캐시 서버가 클라이언트한테 요청받은 파일이 있을 때 해당 파일을 전송


4. Error or Additional Message Handling
▶ Additional Message Handling

▶ Error Handling (Exception 처리 포함)
⊙ Data Server
	- 

	▷ 예외 처리가 적용된 메서드 : 
	⦁ 
		- 

	⦁ 
		- 


⊙ Cache Server

	▷ 예외 처리가 적용된 메서드 : 
	  ⦁ 

		- 
		☆ 기대 효과: 

⊙ Client

	▷ 예외 처리가 적용된 메서드 : 
	  ⦁ 

		- 
		☆ 기대 효과: 


▶ Additional Message Handling


5. Additional Comments (팀플 날짜 기록)

2024/10/05
과제 시작
데이터서버, 캐시 서버, 클라이언트 간 연결 방식 고민 (해결)
1. 데이터 서버에 먼저 캐시 서버 1,2가 연결하면서 포트번호를 등록한다
2. 클라이언트도 데이터 서버에 연결하면서, 등록된 캐시서버 1,2의 포트번호를 요청한다
3. 클라이언트는 데이터 서버로부터 받은 포트번호를 사용해 캐시 서버에 연결한다.

2024/10/06
소켓 연결

2024/10/07
알고리즘 구상

2024/10/09 ~ 2024/10/11
임무 분담 및 알고리즘 구현

2024/10/12 ~ 2024/10/14
코드 무한 디버깅 및 수정
readme 작성, 발표영상 제작